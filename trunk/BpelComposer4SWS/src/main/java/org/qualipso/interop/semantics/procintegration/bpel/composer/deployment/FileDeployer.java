package org.qualipso.interop.semantics.procintegration.bpel.composer.deployment;


import java.io.File;
import java.util.Iterator;
import java.util.Vector;

import org.apache.tools.ant.Project;
import org.apache.tools.ant.taskdefs.Copy;
import org.apache.tools.ant.taskdefs.Javac;
import org.apache.tools.ant.types.Path;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.Controller;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.Dataflow;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.Logger;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.ParameterNode;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.ProcessModel;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.ProcessOutput;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.ServiceInput;
import org.qualipso.interop.semantics.procintegration.bpel.composer.core.ServiceModel;
import org.qualipso.interop.semantics.procintegration.bpel.composer.gui.DeploymentTargetDirectoryDialog;
import org.qualipso.interop.semantics.procintegration.bpel.composer.gui.MessagePanel;


/**
 * A FileDeployer needs to prepare the deployment of the designed process 
 * by generating all relevant artifacts. 
 * After deployment the designed process needs to be accessible
 * through an OWL-S description published in the Web container. This OWL-S
 * service description is grounded to a WSDL Web service description, which is
 * generated by the process execution engine.
 * 
 */
public class FileDeployer {

    protected File  saveDir;
    private File wsdl;
    private File executionPlan;
    private File deploymentDescriptor;
    private File catalogFile;
    private File owls;

    /**
	 * Checks if all service inputs have assignments makes temp dir and initiates deployment.
	 *
	 */
	public void deployProcessInit() {

		// check if all service inputs have assignments
		MessagePanel
				.appendOut("Check all service inputs to have assignments ... ");
		ProcessModel process = Controller.getInstance().getProcess();
		Iterator serviceIter = process.getServices().iterator();
		while (serviceIter.hasNext()) {
			Iterator serviceInputIter = ((ServiceModel) serviceIter.next())
					.getInputs().iterator();
			while (serviceInputIter.hasNext()) {
				ParameterNode root = (ParameterNode) ((ServiceInput) serviceInputIter
						.next()).getRoot();

				if (!root.hasDirectAssignment() && !root.hasDerivedAssignment()) {
					// not deployable because some inputs miss assignment
					MessagePanel
							.appendErrorln("Designed process is not deployable!");
					MessagePanel.appendError("Service: ");
					MessagePanel.appendOutBlue(((ServiceInput) root
							.getParameter()).getService().getName());
					MessagePanel.appendError(" Input parameter: ");
					MessagePanel.appendOutBlue(root.getParameter().getName());
					MessagePanel.appendErrorln(" is missing assignment!");
					return;
				}
			}
		}
		MessagePanel.appendSuccessln("done.");
		
		// create temp directory for generated file 
		File dir = new File("temp/" + process.getProcessName());
		if (!dir.exists()) {
		    dir.mkdir();
		}
		
		// start deployment
		try {
			deployProcess();
		} catch (Exception e) {
			MessagePanel.appendErrorln(e.getMessage());
			Logger.error(e.getMessage());
			e.printStackTrace();
		}
	}

    /**
     * Should be used by specific deployer to generate OWL-S description for
     * designed process.
     * 
     * @param wsdlGroundingURL the wsdl grounding URL
     * 
     * @return OWL-S file
     */
    public File generateOWLS(String wsdlGroundingURL) {

        OWLSWriter owlsWriter = new OWLSWriter();
        return owlsWriter.generateOWLS(wsdlGroundingURL);
    }
    
    /**
     * Should be used by specific deployer to generate WSDL file for
     * designed process.
     * 
     * @return WSDL file
     */
    public File generateWsdl() {

        WsdlWriter wsdlWriter = new WsdlWriter();
        return wsdlWriter.generateWSDL();
    }

    /**
     * Should be used by specific deployer to generate 
     * a deployment descriptor for the designed process.
     * 
     * @return deployment descriptor file
     */
    public File generateDeploymentDescriptor() {

        ActiveBPELDeploymentWriter pddWriter = new ActiveBPELDeploymentWriter();
        return pddWriter.generateDeploymentDescriptor();
    }

    /**
     * Should be used by specific deployer to generate 
     * a catalog file for the designed process.
     * 
     * @return deployment descriptor file
     */
    public File generateCatalogFile() {

        ActiveBPELDeploymentWriter pddWriter = new ActiveBPELDeploymentWriter();
        return pddWriter.generateCatalogFile();
    }
    
	/**
	 * Generates dataflow descriptions from assignment information for each
	 * service input and process output in pull-mode .
	 * 
	 * @return Vector of dataflow description files
	 */
	public Vector generateDataflows() {
		Vector dataflows = new Vector();
		ProcessModel process = Controller.getInstance().getProcess();

		// process input assignments and service to service assignemnts
		Iterator serviceIter = process.getServices().iterator();
		while (serviceIter.hasNext()) {
			ServiceModel service = (ServiceModel) serviceIter.next();

			Iterator inputIter = service.getInputs().iterator();
			Dataflow dataflow = service.getDataflow();
			dataflow.resetDataflows();
			dataflow.resetCreates();
            while (inputIter.hasNext()) {
				ServiceInput input = (ServiceInput) inputIter.next();
				this.traverseAndGenerateDataflowRules((ParameterNode) input
						.getRoot(), dataflow);
			}

			// add dataflow descriptions
			dataflows.add(dataflow.serializeDataflows());
			//dataflows.add(dataflow.serializeCreates());
		}

		// process output assignments
		Iterator outputIter = process.getProcessOutputs().iterator();
        Dataflow dataflow = process.getOutputDataflow();
        dataflow.resetDataflows();
        dataflow.resetCreates();		while (outputIter.hasNext()) {
			ProcessOutput output = (ProcessOutput) outputIter.next();
			this.traverseAndGenerateDataflowRules((ParameterNode) output
					.getRoot(), dataflow);
		}
		
		// add dataflow description
		dataflows.add(process.getOutputDataflow().serializeDataflows());

		return dataflows;
	}

	/**
	 * Generate dataflow rule for root and add to dataflow of corresponding
	 * service if root is direct assignment target. Traverse children
	 * recursively.
	 * 
	 * @param root the parameter node to travers recursively
	 * @param dataflow the dataflow to generate rules in
	 */
	private void traverseAndGenerateDataflowRules(ParameterNode root,
			Dataflow dataflow) {

		// create empty node for root if root is assigned through direct
		// assignments of its children
		if (root.hasDerivedAssignment() && !root.hasDirectAssignment()) {
			dataflow.createEmptyNode(root);

			// traverse children
			Iterator childIter = root.getChildren().iterator();
			while (childIter.hasNext()) {
				ParameterNode child = (ParameterNode) childIter.next();
				traverseAndGenerateDataflowRules(child, dataflow);
			}

			// generate dataflow
		} else if (root.hasDirectAssignment()) {
			dataflow.addAssignmentDataflow(root
					.getAssignmentSourceParameterNode(), root);
		}

	}

//	/**
//	 * Provides the loaded semantic bridges in a vector of filenames.
//	 * 
//	 * @return Vector of Semantic Bridges
//	 */
//	public Vector getSemanticBridges() {
//		Vector semanticBridgesFilenames = new Vector();
//		ProcessModel process = Controller.getInstance().getProcess();
//		Vector semanticBridges = process.getSemanticBridges();
//		Iterator iter = semanticBridges.iterator();
//		while (iter.hasNext()) {
//			File filename = ((SemanticBridge) iter.next()).getSemanticBridgeLocalFile();
//			semanticBridgesFilenames.add(filename);
//		}
//		return semanticBridgesFilenames;
//	}

	/**
	 * Using ANT API for copying files.
	 * 
	 * @param srcFile the source file
	 * @param targetDir the target directory
	 */
	public void copy(File srcFile, File targetDir) {

	    /**
	     * Ant copyer.
	     * 
	     * @author rwe
	     *
	     */
		final class Copyer extends Copy {
		    
		    /**
		     * Constructor for Ant Copyer.
		     */
			public Copyer() {
				this.setProject(new Project());
				this.getProject().init();
				this.setTaskType("copy");
				this.setTaskName("copy");
			}
		}

		Copyer copy = new Copyer();
		copy.setFile(srcFile);
		copy.setTodir(targetDir);
		copy.setOverwrite(true);
		copy.setVerbose(true);
		copy.execute();
	}

	/**
	 * Using ANT API for compiling Web service implementation.
	 * 
	 * @param javaSrcDir the source directory
	 * @param targetDir the target directory
	 */
	public void compile(File javaSrcDir, File targetDir) {

	    /**
	     * Ant compiler.
	     * 
	     * @author rwe
	     *
	     */
		final class Compiler extends Javac {

		    /**
		     * Constructor for Ant Compiler
		     */
		    public Compiler() {
				this.setProject(new Project());
				this.getProject().init();
				this.setTaskType("javac");
				this.setTaskName("compile");
			}
		}

		Compiler compiler = new Compiler();
		compiler.setSrcdir(new Path(compiler.getProject(), javaSrcDir
				.getAbsolutePath()));
		compiler.setDestdir(targetDir);
		compiler.execute();
	}

	/**
	 * Opens dialog to set target dir.
	 * 
	 * @param defaultDirPath the default directory to display
	 * 
	 * @return target directory
	 */
	public File getTargetDir(String defaultDirPath) {

		DeploymentTargetDirectoryDialog dialog = new DeploymentTargetDirectoryDialog(
				defaultDirPath);
		String targetDirPath = dialog.getText();

		// check correct directory selection
		if (targetDirPath != null) {
			File targetDir = new File(targetDirPath);

			// check if existing directory
			if (targetDir.exists() && targetDir.isDirectory()) {
				return targetDir;
			}
		}

		return null;
	}

	/**
     * Deploys composition outcome to file system.
     */
    public void deployProcess() {
            
        // generate all files including dataflows
        Vector dataflows = generateFiles();
    
    		// copy files
    		File targetDir = getTargetDir("C:/Dokumente und Einstellungen/rwe/Desktop");
    		
    		if (targetDir != null) {
    			this.saveDir = new File(targetDir, 
    			            Controller.getInstance().getProcess().getProcessName());
    			saveDir.mkdir();
    			MessagePanel.appendOut("    Saving files to ");
    			MessagePanel.appendOutBlue(saveDir.getAbsolutePath());
    			MessagePanel.appendOutln(".");
                copy(wsdl, saveDir);
    			copy(executionPlan, saveDir);
                copy(deploymentDescriptor, saveDir);
                copy(catalogFile, saveDir);
                copy(owls, saveDir);
    
    			Iterator iter1 = dataflows.iterator();
    			while (iter1.hasNext()) {
    				copy((File) iter1.next(), saveDir);
    			}
    		} else {
    			MessagePanel.appendOutln("    No files deloyed.");
    		}
    	}

    /**
     * Generates all files necessary for deployment and returns the
     * generated dataflows.
     * 
     * @return generated dataflows
     */
    protected Vector generateFiles() {        
        // generate process descriptions
        owls = this.generateOWLS("http://localhost:8080/active-bpel/services/" 
                + Controller.getInstance().getProcess().getProcessName() 
                + "_PartnerLinkService?wsdl");

        // generate WSDL file
        wsdl = this.generateWsdl();
        
        // generate dataflows before generating execution plan to get dataflow sources
        Vector dataflows = this.generateDataflows();
        executionPlan = null;
        try {
        	executionPlan = BpelWriter.generateBpelProcess();
        } catch (Exception e) {
        	Logger.error("Error writing execution plan");
        	e.printStackTrace();
        }
   
        // generate Deployment Descriptor file
        deploymentDescriptor = this.generateDeploymentDescriptor();
   
        // generate Deployment Descriptor file
        catalogFile = this.generateCatalogFile();
        
        return dataflows;
    }

}
